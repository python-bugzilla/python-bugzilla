#!/usr/bin/python -tt
#
# bugzilla - a commandline frontend for the python bugzilla module
#
# Copyright (C) 2007, 2008, 2009, 2010, 2011 Red Hat Inc.
# Author: Will Woods <wwoods@redhat.com>
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2 of the License, or (at your
# option) any later version.  See http://www.gnu.org/copyleft/gpl.html for
# the full text of the license.

import getpass
import locale
import logging
import optparse
import os
import re
import socket
import sys
import tempfile
import xmlrpclib

import bugzilla
import bugzilla.util

version = '0.7.0'
default_bz = 'https://bugzilla.redhat.com/xmlrpc.cgi'

_is_unittest = bool(os.getenv("__BUGZILLA_UNITTEST"))
cmdlist = ['login', 'new', 'query', 'modify', 'attach', 'info']
format_field_re = re.compile("%{([a-z0-9_]+)(?::([^}]*))?}")

log = logging.getLogger("bugzilla")
handler = logging.StreamHandler(sys.stderr)
handler.setFormatter(logging.Formatter(
    "[%(asctime)s] %(levelname)s (%(module)s:%(lineno)d) %(message)s",
    "%H:%M:%S"))
log.addHandler(handler)


################
# Util helpers #
################

def to_encoding(ustring):
    if isinstance(ustring, basestring):
        if isinstance(ustring, unicode):
            return ustring.encode(locale.getpreferredencoding(), 'replace')
        return ustring
    return u''


def open_without_clobber(name, *args):
    '''Try to open the given file with the given mode; if that filename exists,
    try "name.1", "name.2", etc. until we find an unused filename.'''
    fd = None
    count = 1
    orig_name = name
    while fd is None:
        try:
            fd = os.open(name, os.O_CREAT | os.O_EXCL, 0666)
        except OSError as e:
            if e.errno == os.errno.EEXIST:
                name = "%s.%i" % (orig_name, count)
                count += 1
            else:
                raise IOError(e.errno, e.strerror, e.filename)
    fobj = open(name, *args)
    if fd != fobj.fileno():
        os.close(fd)
    return fobj


##################
# Option parsing #
##################

def setup_parser():
    u = ("%%prog [global options] COMMAND [command-options]"
         "\nCommands: %s" % ','.join(cmdlist))
    p = optparse.OptionParser(usage=u, version=version)
    p.disable_interspersed_args()
    p.epilog = 'Try "bugzilla COMMAND --help" for command-specific help.'

    # General bugzilla connection options
    p.add_option('--bugzilla', default=default_bz,
            help="bugzilla XMLRPC URI. default: %s" % default_bz)
    p.add_option('--bztype', default='auto',
            help="Bugzilla type. Autodetected if not set. "
                 "Available types: %s" % " ".join(bugzilla.classlist))
    p.add_option('--user',
            help="username")
    p.add_option('--password',
            help="password")
    p.add_option('--cookiefile',
            help="cookie file to use for bugzilla authentication")
    p.add_option('--verbose', action='store_true',
            help="give more info about what's going on")
    p.add_option('--debug', action='store_true',
            help="output bunches of debugging info")

    # Generate the man page, dump to stdout. Not for end users
    p.add_option('--generate-man', action='store_true',
            help=optparse.SUPPRESS_HELP)

    return p


def setup_action_parser(action):
    p = optparse.OptionParser(usage="%%prog %s [options]" % action)

    if action == 'new':
        # TODO: product and version could default to current system
        # info (read from /etc/redhat-release?)
        p.set_description("Create a new bug report.")
        p.add_option('-p', '--product',
                help="REQUIRED: product name (list with 'bugzilla info -p')")
        p.add_option('-v', '--version',
                help="REQUIRED: product version")
        p.add_option('-c', '--component',
                help="REQUIRED: component name "
                     "(list with 'bugzilla info -c PRODUCT')")
        p.add_option('-l', '--comment', dest='description',
                help="REQUIRED: initial bug comment")
        p.add_option('-s', '--short_desc', '--summary', dest='summary',
                help="REQUIRED: bug summary")
        p.add_option('-o', '--os', dest='op_sys',
                help="OPTIONAL: operating system (default: Linux)")
        p.add_option('-a', '--arch', dest='platform',
                help="OPTIONAL: arch this bug occurs on (default: All)")
        p.add_option('--severity',
                help="OPTIONAL: bug severity (default: medium)")
        p.add_option('--priority',
                help="OPTIONAL: bug priority (default: medium)")
        p.add_option('-u', '--url', dest='bug_file_loc',
                help="OPTIONAL: URL for further bug info")
        p.add_option('--cc', metavar='CC[, CC, ...]',
                help="OPTIONAL: add emails to initial CC list")
        p.add_option('--blocked', metavar='BUGID[, BUGID, ...]',
                help="OPTIONAL: add bug_ids blocked by this bug")
        p.add_option('--dependson', metavar='BUGID[, BUGID, ...]',
                help="OPTIONAL: add bug_ids that this bug depends on")
        # no API to attach files during bug creation, so no --attach :/

    elif action == 'query':
        p.set_description("List bug reports that match the given criteria.")
        # General bug metadata
        p.add_option('-b', '--bug_id', default=None,
                help="specify individual bugs by IDs, separated with commas")
        p.add_option('-p', '--product',
                help="product name, comma-separated "
                     "(list with 'bugzilla info -p')")
        p.add_option('-v', '--version',
                help="product version")
        p.add_option('-c', '--component',
                help="component name(s), comma-separated "
                     "(list with 'bugzilla info -c PRODUCT')")
        p.add_option('--components_file', default=None,
                help="list of component names from a file, one component "
                     "per line (list with 'bugzilla info -c PRODUCT')")
        p.add_option('-l', '--long_desc',
                help="search inside bug comments")
        p.add_option('-m', '--target_milestone',
                help="search for a target milestone")
        p.add_option('-s', '--short_desc',
                help="search bug summaries")
        p.add_option('-t', '--bug_status', default="ALL",
                help="comma-separated list of bug statuses to accept "
                     "[Default:all]")
        p.add_option('-x', '--bug_severity', '--severity',
                help="search severities, comma-separated")
        p.add_option('-z', '--priority',
                help="search priorities, comma-separated")

        # Email
        p.add_option('-E', '--emailtype', default="substring",
                help="Email: specify searching option for emails, "
                     "ie. substring, notsubstring, exact, ... "
                     "[Default: substring]")
        p.add_option('-o', '--cc',
                help="Email: search cc lists for given address")
        p.add_option('-r', '--reporter',
                help="Email: search reporter email for given address")
        p.add_option('-a', '--assigned_to',
                help="Email: search for bugs assigned to this address")
        p.add_option('-q', '--qa_contact',
                help="Email: search for bugs which have QA Contact "
                     "assigned to this address")

        # Strings
        p.add_option('-u', '--url',
                help="search keywords field for given url")
        p.add_option('-U', '--url_type',
                help="specify searching option for urls, "
                     "ie. anywords, allwords, nowords")
        p.add_option('-k', '--keywords',
                help="search keywords field for specified words")
        p.add_option('-K', '--keywords_type',
                help="specify searching option for keywords, "
                     "ie. anywords, allwords, nowords")
        p.add_option('-w', '--status_whiteboard',
                help="search Status Whiteboard field for specified words")
        p.add_option('-W', '--status_whiteboard_type',
                help="specify searching option for Status Whiteboard, "
                     "ie. anywords, allwords, nowords")

        # Boolean Charts
        p.add_option('-B', '--booleantype', default="substring",
                help="specify searching option for booleans, ie. substring, "
                     "notsubstring, exact, ... [Default: substring]")
        p.add_option('--boolean_query', action="append",
                help="Boolean:Create your own query. Format: "
                     "BooleanName-Condition-Parameter &/| ... . ie, "
                     "keywords-substring-Partner & "
                     "keywords-notsubstring-OtherQA")
        p.add_option('--blocked', action="append",
                help="Boolean:search for bugs that block this bug ID")
        p.add_option('--dependson', action="append",
                help="Boolean:search for bugs that depend on this bug ID")
        p.add_option('--flag', action='append',
                help="Boolean:search for bugs that have certain "
                     "flag states present")
        p.add_option('--qa_whiteboard', action="append",
                help="Boolean:search for bugs that have certain QA "
                     "Whiteboard text present")
        p.add_option('--devel_whiteboard', action="append",
                help="Boolean:search for bugs that have certain "
                     "Devel Whiteboard text present")
        p.add_option('--alias', action="append",
                help="Boolean:search for bugs that have the provided alias")
        p.add_option('--fixed_in', action="append",
                help="search Status Whiteboard field for specified words")

        # Precomposed queries
        p.add_option('--from-url',
                help="Use the query given by a query.cgi URL. (Use quotes!)")

        # Used by unit tests, not for end user consumption
        p.add_option('--test-return-query', action="store_true",
                     help=optparse.SUPPRESS_HELP)

    elif action == 'info':
        p.set_description("Get information about the bugzilla server.")
        p.add_option('-p', '--products', action='store_true',
                help='Get a list of products')
        p.add_option('-c', '--components', metavar="PRODUCT",
                help='List the components in the given product')
        p.add_option('-o', '--component_owners', metavar="PRODUCT",
                help='List components (and their owners)')
        p.add_option('-v', '--versions', metavar="PRODUCT",
                help='List the versions for the given product')
    elif action == 'modify':
        p.set_usage("%prog modify [options] BUGID [BUGID...]")
        p.set_description("Modify one or more bugs.")
        p.add_option('-l', '--comment',
                help='Add a comment')
        # TODO: --keyword, --tag, ...
        p.add_option('-k', '--close', metavar="RESOLUTION",
                help='Close with the given resolution')
        p.add_option('-d', '--dupeid', metavar="ORIGINAL",
                help='ID of original bug (implies -k DUPLICATE)')
        p.add_option('-p', '--private', action='store_true', default=False,
                help='Mark as private')
        p.add_option('-s', '--status',
                help='Change status of bug')
        p.add_option('--assignee',
                help='Assign bugzilla to assignee')
        p.add_option('--qa_contact',
                help='Change QA contact')
        p.add_option('-f', '--flag', action='append',
                help='Update bugzilla flags with requested type, '
                     'ie fedora-cvs? (Use a new option for each flag)')
        p.add_option('--cc', action='append',
                help='Add an email to the cc list')
        p.add_option('-F', '--fixed_in', metavar="VERSION",
                help='"Fixed in version" field')

    elif action == 'attach':
        p.set_usage('''
  %prog attach --file=FILE --desc=DESC [--type=TYPE] BUGID [BUGID...]
  %prog attach --get=ATTACHID --getall=BUGID [...]
  %prog attach --type=TYPE BUGID [BUGID...]''')
        p.set_description("Attach files or download attachments.")
        p.add_option('-f', '--file', metavar="FILENAME",
                help='File to attach, or filename for data provided on stdin')
        p.add_option('-d', '--description', metavar="DESCRIPTION", dest='desc',
                help="A short description of the file being attached")
        p.add_option('-t', '--type', metavar="MIMETYPE",
                help="Mime-type for the file being attached")
        p.add_option('-g', '--get', metavar="ATTACHID", action="append",
                default=[], help="Download the attachment with the given ID")
        p.add_option("--getall", "--get-all", metavar="BUGID", action="append",
                default=[], help="Download all attachments on the given bug")

    elif action == 'login':
        p.set_usage('%prog login [username [password]]')
        p.set_description("Log into bugzilla and save a login cookie.")

    if action in ['new', 'query']:
        # output modifiers
        p.add_option('-f', '--full', action='store_const', dest='output',
                const='full', default='normal',
                help="output detailed bug info")
        p.add_option('-i', '--ids', action='store_const', dest='output',
                const='ids', help="output only bug IDs")
        p.add_option('-e', '--extra', action='store_const',
                dest='output', const='extra',
                help="output additional bug information "
                     "(keywords, Whiteboards, etc.)")
        p.add_option('--oneline', action='store_const', dest='output',
                const='oneline',
                help="one line summary of the bug (useful for scripts)")
        p.add_option('--raw', action='store_const', dest='output',
                const='raw', help="raw output of the bugzilla contents")
        p.add_option('--outputformat',
                help="Print output in the form given. "
                     "You can use RPM-style tags that match bug "
                     "fields, e.g.: '%{bug_id}: %{short_desc}'")

    return p


####################
# Command routines #
####################

def generate_man_page():
    from logilab.common.optik_ext import ManHelpFormatter
    import datetime

    today = datetime.date.today()
    datestr = today.strftime("%B %d, %Y")
    manpage = \
'''.TH bugzilla 1  "%s" "version %s" "User Commands"
.SH NAME
bugzilla \- command-line interface to Bugzilla over XML-RPC
.SH SYNOPSIS
.B bugzilla
[\\fIoptions\\fR] [\\fIcommand\\fR] [\\fIcommand-options\\fR]
.SH DESCRIPTION
.PP
.BR bugzilla
is a command-line utility that allows access to the XML-RPC interface provided
by Bugzilla.
.PP
\\fIcommand\\fP is one of:
.br
.I \\fR * login - log into the given bugzilla instance
.br
.I \\fR * new - create a new bug
.br
.I \\fR * query - search for bugs matching given criteria
.br
.I \\fR * modify - modify existing bugs
.br
.I \\fR * attach - attach files to existing bugs, or get attachments
.br
.I \\fR * info - get info about the given bugzilla instance
''' % (datestr, version)

    manformatter = ManHelpFormatter()
    parser = setup_parser()
    parser.formatter = manformatter

    opt_section = parser.format_option_help()
    manpage += opt_section.replace("OPTIONS", "GLOBAL OPTIONS")
    for action in cmdlist:
        action_parser = setup_action_parser(action)
        action_parser.remove_option("--help")
        action_parser.formatter = manformatter
        opt_section = action_parser.format_option_help()
        manpage += opt_section.replace("OPTIONS",
                                       '\[oq]%s\[cq] OPTIONS' % action.upper())
    manpage += \
'''.SH EXAMPLES
.PP
.RS 0
bugzilla query --bug_id 62037

bugzilla query --version 15 --component python-bugzilla

bugzilla login

bugzilla create -p Fedora -v rawhide -c python-bugzilla \\\\
         --summary "python-bugzilla causes headaches" \\\\
         --comment "python-bugzilla made my brain hurt when I used it."

bugzilla attach --file ~/Pictures/cam1.jpg --desc "me, in pain" $BUGID

bugzilla attach --getall $BUGID

bugzilla modify --close NOTABUG --comment "Actually, you're hungover." $BUGID

.SH EXIT STATUS
.BR bugzilla
normally returns 0 if the requested command was successful.
Otherwise, exit status is 1 if
.BR bugzilla
is interrupted by the user (or a login attempt fails), 2 if a
socket error occurs (e.g. TCP connection timeout), and 3 if the server returns
an XML-RPC fault.
.SH NOTES
Not everything that's exposed in the Web UI is exposed by XML-RPC, and not
everything that's exposed by XML-RPC is used by
.BR bugzilla .
.SH BUGS
Bugs? In a sub-1.0 release? Preposterous.
.SH AUTHOR
Will Woods <wwoods@redhat.com>'''

    print manpage


def do_query(bz, opt, parser):
    # Construct the query from the list of queryable options
    q = dict()
    # Parse preconstructed queries.
    u = getattr(opt, 'from_url', None)
    if u:
        q = bugzilla.util.url_to_query(u)

    # TODO: flags to save queries, list/perform saved queries
    # TODO: use the given scheme/host for the bugzilla URL

    if opt.components_file:
        # Components slurped in from file (one component per line)
        # This can be made more robust
        clist = []
        f = open(opt.components_file, 'r')
        for line in f.readlines():
            line = line.rstrip("\n")
            clist.append(line)
        opt.component = clist

    if opt.bug_status:
        # FIXME: statuses can differ between bugzilla instances..
        val = opt.bug_status
        stat = val
        if val == 'ALL':
            # leaving this out should return bugs of any status
            stat = None
        elif val == 'DEV':
            # Alias for all development bug statuses
            stat = ['NEW', 'ASSIGNED', 'NEEDINFO', 'ON_DEV',
                'MODIFIED', 'POST', 'REOPENED']
        elif val == 'QE':
            # Alias for all QE relevant bug statuses
            stat = ['ASSIGNED', 'ON_QA', 'FAILS_QA', 'PASSES_QA']
        elif val == 'EOL':
            # Alias for EndOfLife bug statuses
            stat = ['VERIFIED', 'RELEASE_PENDING', 'CLOSED']
        elif val == 'OPEN':
            # non-Closed statuses
            stat = ['NEW', 'ASSIGNED', 'MODIFIED', 'ON_DEV', 'ON_QA',
                'VERIFIED', 'RELEASE_PENDING', 'POST']
        opt.bug_status = stat

    # Convert all comma separated list parameters to actual lists,
    # which is what bugzilla wants
    # According to bugzilla docs, any parameter can be a list, but
    # let's only do this for options we explicitly mention can be
    # comma separated.
    for optname in ["bug_severity", "bug_id", "bug_status", "component",
                    "priority", "product"]:
        val = getattr(opt, optname, None)
        if type(val) is not str:
            continue
        setattr(opt, optname, val.split(","))

    include_fields = None
    # To optimize speed and reduce network traffic through lookups, we
    # specifically tell bugzilla the exact data we want.  This allows us
    # make one call to output the data, rather than have a follow-on
    # getbug() to grab more info than what the default has.
    # Testing has shown this to be a _huge_ time saver.  Unfortunately,
    # this list and the output format have to be in _sync_.  Otherwise,
    # you lose speed by doing a look-up for each new output element.
    if opt.output == 'oneline':
        include_fields = ['bug_id', 'bug_status', 'assigned_to',
            'component', 'target_milestone', 'short_desc', 'flags',
            'keywords', 'blockedby']

    elif opt.output == 'normal':
        include_fields = ['bug_id', 'bug_status', 'assigned_to',
            'short_desc']

    if opt.outputformat:
        include_fields = []
        for fieldname, ignore in format_field_re.findall(opt.outputformat):
            include_fields.append(fieldname)

    built_query = bz.build_query(
        product=getattr(opt, "product", None),
        component=getattr(opt, "component", None),
        version=getattr(opt, "version", None),
        reporter=getattr(opt, "reporter", None),
        bug_id=getattr(opt, "bug_id", None),
        short_desc=getattr(opt, "short_desc", None),
        cc=getattr(opt, "cc", None),
        assigned_to=getattr(opt, "assigned_to", None),
        qa_contact=getattr(opt, "qa_contact", None),
        status=getattr(opt, "bug_status", None),
        blocked=getattr(opt, "blocked", None),
        dependson=getattr(opt, "dependson", None),
        keywords=getattr(opt, "keywords", None),
        keywords_type=getattr(opt, "keywords_type", None),
        url=getattr(opt, "url", None),
        url_type=getattr(opt, "url_type", None),
        status_whiteboard=getattr(opt, "status_whiteboard", None),
        status_whiteboard_type=getattr(opt, "status_whiteboard_type", None),
        fixed_in=getattr(opt, "fixed_in", None),
        fixed_in_type=getattr(opt, "fixed_in_type", None),
        flag=getattr(opt, "flag", None),
        alias=getattr(opt, "alias", None),
        qa_whiteboard=getattr(opt, "qa_whiteboard", None),
        devel_whiteboard=getattr(opt, "devel_whiteboard", None),
        boolean_query=getattr(opt, "boolean_query", None),
        bug_severity=getattr(opt, "bug_severity", None),
        priority=getattr(opt, "priority", None),
        target_milestone=getattr(opt, "target_milestone", None),
        emailtype=opt.emailtype,
        booleantype=opt.booleantype,
        include_fields=include_fields)

    built_query.update(q)
    q = built_query

    if not q:
        parser.error("'query' command requires additional arguments")
    if opt.test_return_query:
        return q
    return bz.query(q)


def _do_info(bz, opt):
    """
    Handle the 'info' subcommand
    """
    # All these commands call getproducts internally, so do it up front
    # with minimal include_fields for speed
    include_fields = ["name", "id"]
    if opt.versions:
        include_fields.append("versions")
    products = bz.getproducts(include_fields=include_fields)

    if opt.products:
        for name in sorted([p["name"] for p in products]):
            print name

    if opt.components:
        for name in sorted(bz.getcomponents(opt.components)):
            print name

    if opt.component_owners:
        # Looking up this info for rhbz 'Fedora' product is sloooow
        # since there are so many components. So delay getting this
        # info until as late as possible
        bz.refresh_products(names=[opt.component_owners],
                            include_fields=include_fields + ["components"])

        component_details = bz.getcomponentsdetails(opt.component_owners)
        for c in sorted(component_details):
            print to_encoding(u"%s: %s" %
                              (c, component_details[c]['initialowner']))

    if opt.versions:
        for p in products:
            if p['name'] != opt.versions:
                continue
            if "versions" in p:
                for v in p['versions']:
                    print to_encoding(v["name"])
            break


def _format_output(bz, opt, buglist):
    if opt.outputformat:
        special_fields = {
            'flag': lambda b, f: b.get_flag_status(f),
            'whiteboard': lambda b, wb: b.getwhiteboard(wb),
        }

        def bug_field(matchobj):
            (fieldname, rest) = matchobj.groups()

            if fieldname in special_fields:
                val = special_fields[fieldname](b, rest)
            else:
                val = getattr(b, fieldname)
            if type(val) is list:
                val = ','.join(val)
            try:
                return str(val)
            except UnicodeEncodeError:
                return to_encoding(val)
        for b in buglist:
            print format_field_re.sub(bug_field, opt.outputformat)

    elif opt.output == 'ids':
        for b in buglist:
            print b.bug_id

    elif opt.output == 'full':
        fullbuglist = bz.getbugs([b.bug_id for b in buglist])
        for b in fullbuglist:
            print to_encoding(u'#%s %s - %s - %s' %
                    (b.bug_id, b.bug_status, b.assigned_to, b.short_desc))

            if hasattr(b, "cc"):
                print "CC: %s" % " ".join(b.cc)
            if hasattr(b, "blocked"):
                print "Blocked: %s" % " ".join([str(i)
                                                for i in b.blocked or []])
            if hasattr(b, "dependson"):
                print ("Depends: %s" %
                       " ".join([str(i) for i in b.dependson or []]))

            for c in getattr(b, "longdescs", []):
                if 'email' in c:
                    email = c['email']
                elif 'safe_email' in c:
                    email = c['safe_email']
                else:
                    email = 'Unknown'
                print to_encoding(u"* %s - %s (%s):\n%s\n" % (c['time'],
                    c['author'], email, c['body']))

    elif opt.output == 'normal':
        for b in buglist:
            print to_encoding(u'#%s %8s - %s - %s' %
                    (b.bug_id, b.bug_status, b.assigned_to, b.short_desc))

    elif opt.output == 'extra':
        print "Grabbing 'extra' bug information. This could take a moment."
        fullbuglist = bz.getbugs([b.bug_id for b in buglist])
        for b in fullbuglist:
            print to_encoding(u'#%s %s - %s - %s' %
                    (b.bug_id, b.bug_status, b.assigned_to, b.short_desc))
            if hasattr(b, 'keywords') and b.keywords:
                print to_encoding(u" +Keywords: %s" % b.keywords)
            if hasattr(b, 'qa_whiteboard') and b.qa_whiteboard:
                print to_encoding(u" +QA Whiteboard: %s" % b.qa_whiteboard)
            if hasattr(b, 'status_whiteboard') and b.status_whiteboard:
                print to_encoding(u" +Status Whiteboard: %s" %
                        b.status_whiteboard)
            if hasattr(b, 'devel_whiteboard') and b.devel_whiteboard:
                print to_encoding(u" +Devel Whiteboard: %s" %
                        b.devel_whiteboard)
        print "\nBugs listed: ", len(buglist)

    elif opt.output == 'oneline':
        for b in buglist:
            cve = ""
            flags = ""
            if hasattr(b, "flags"):
                flags = "".join([str(i) for i in b.flags.split(',')])

            keywords = getattr(b, "keywords", "")
            if type(keywords) is list:
                keywords = " ".join(keywords)

            # grab CVE from keywords and blockers
            if keywords.find("Security") != -1 and b.blockedby:
                for bl in str(b.blockedby).split(','):
                    cvebug = bz.getbug(bl)
                    for cb in cvebug.alias:
                        if cb.find("CVE") != -1:
                            cve += cb + " "

            # bugzilla.redhat.com has component as a list
            if type(b.component) == list:
                b.component = ','.join(b.component)
            print to_encoding(u"#%s %8s %22s %s\t[%s] %s %s" %
                    (b.bug_id, b.bug_status, b.assigned_to, b.component,
                        b.target_milestone, flags, cve))

    elif opt.output == 'raw':
        fullbuglist = bz.getbugs([b.bug_id for b in buglist])
        for b in fullbuglist:
            print "Bugzilla %s: " % b.bug_id
            for a in dir(b):
                print to_encoding(u"ATTRIBUTE[%s]: %s" % (a, getattr(b, a)))
            print "\n\n"

    else:
        raise RuntimeError("Unknown output type '%s'" % opt.output)


def _do_new(bz, opt):
    data = {}
    allopts = ["product", "version", "component", "description",
               "summary", "op_sys", "platform", "severity", "priority",
               "bug_file_loc", "cc", "blocked", "dependson"]

    # Handle options that take a list format
    multiopts = ['cc', 'blocked', 'dependson']

    for key in allopts:
        if not hasattr(opt, key) or getattr(opt, key) is None:
            continue

        data[key] = getattr(opt, key)
        if key not in multiopts:
            continue
        data[key] = data[key].split(",")

    b = bz.createbug(**data)
    b.refresh()
    return [b]


def _do_modify(bz, opt, args):
    bugid_list = reduce(lambda l1, l2: l1 + l2,
                        [a.split(",") for a in args])

    # Iterate over a list of Bug objects
    # FIXME: this should totally use some multicall magic
    buglist = bz.getbugssimple(bugid_list)
    log.debug("bz.getbugssimple(%s) -> %s" % (bugid_list, buglist))
    if not buglist:
        raise RuntimeError('No bugs were found. Check your bug IDs.')

    for bugid, bug in zip(bugid_list, buglist):
        if not bug:
            log.error("failed to load bug %s" % bugid)
            continue

        log.debug("modifying bug %s" % bug.bug_id)
        if opt.status:
            log.debug("  set status: %s" % opt.status)
            bug.setstatus(opt.status, opt.comment, private=opt.private)

        elif opt.close:
            log.debug("  close %s" % opt.close)
            bug.close(opt.close, comment=opt.comment,
                      isprivate=opt.private, dupeid=opt.dupeid)

        elif opt.assignee:
            log.debug("  assignee %s" % opt.assignee)
            bug.setassignee(assigned_to=opt.assignee, comment=opt.comment)

        elif opt.qa_contact:
            log.debug("  qa_contact %s" % opt.qa_contact)
            bug.setassignee(qa_contact=opt.qa_contact, comment=opt.comment)

        elif opt.cc:
            ccs = opt.cc[:]
            log.debug("  cc'ing %s" % opt.cc)
            bug.addcc(ccs, comment=opt.comment)

        elif opt.flag:
            log.debug("  flag %s" % opt.flag)
            flags = {}

            for f in opt.flag:
                (flagname, status) = (f[:-1], f[-1])
                flags[flagname] = status
            bug.updateflags(flags)

        elif opt.comment:
            # This has to be last and signifies a stand-alone comment
            log.debug("  add comment: %s" % opt.comment)
            bug.addcomment(opt.comment, opt.private)

    # stuff that I do in batch mode:
    if opt.fixed_in:
        data = {}
        if opt.fixed_in:
            data['fixed_in'] = opt.fixed_in
        bz._update_bugs(bugid_list, data)


def _do_attach(bz, opt, parser, args):
    # Getting attachments
    if opt.get or opt.getall:
        if args:
            parser.error("Extra args '%s' not used for getting attachments" %
                         args)

        for bug in bz.getbugs(opt.getall):
            opt.get += [a['attach_id'] for a in bug.attachments]

        for attid in set(opt.get):
            att = bz.openattachment(attid)
            outfile = open_without_clobber(att.name, "wb")
            data = att.read(4096)
            while data:
                outfile.write(data)
                data = att.read(4096)
            print "Wrote %s" % outfile.name

        return

    # Setting attachments
    if not args:
        parser.error("Bug ID must be specified for setting attachments")

    if not opt.type:
        try:
            import magic
        except ImportError:
            RuntimeError("specify --type or install python-magic")
        mimemagic = magic.open(magic.MAGIC_MIME_TYPE)
        mimemagic.load()

    if sys.stdin.isatty():
        # stdin is a tty -> normal CLI
        if not opt.type:
            opt.type = mimemagic.file(opt.file)
        fileobj = open(opt.file)

    else:
        # piped input on stdin
        # write it to a tempfile - and get the filetype if we need it
        fileobj = tempfile.NamedTemporaryFile(prefix="bugzilla-attach.")
        data = sys.stdin.read(4096)
        if not opt.type:
            opt.type = mimemagic.buffer(data)
        while data:
            fileobj.write(data)
            data = sys.stdin.read(4096)
        fileobj.seek(0)

    # Upload attachments
    for bugid in args:
        attid = bz.attachfile(bugid, fileobj, opt.desc,
                              filename=opt.file,
                              contenttype=opt.type,
                              ispatch=(opt.type == "text/x-patch"))
        print "Created attachment %i on bug %s" % (attid, bugid)


#################
# Main function #
#################

def main(bzinstance=None):
    parser = setup_parser()
    (global_opt, args) = parser.parse_args()

    if global_opt.generate_man:
        generate_man_page()
        return 0

    if global_opt.debug:
        log.setLevel(logging.DEBUG)
    elif global_opt.verbose:
        log.setLevel(logging.INFO)
    else:
        log.setLevel(logging.WARN)

    # Get our action
    if len(args) == 0:
        parser.error("No command specified, command must be one of: %s" %
                     ','.join(cmdlist))
    action = args.pop(0)
    if action not in cmdlist:
        parser.error("Unknown command '%s', command must be one of: %s" %
                     (action, ','.join(cmdlist)))

    # Parse action-specific args
    action_parser = setup_action_parser(action)
    (opt, args) = action_parser.parse_args(args)

    # Connect to bugzilla
    log.info('Connecting to %s', global_opt.bugzilla)

    if global_opt.bztype == 'auto':
        log.info('Autodetecting Bugzilla type')
        # Cheat a little, for the sake of speed
        if 'bugzilla.redhat.com' in global_opt.bugzilla:
            log.info('Using RHBugzilla for URL containing bugzilla.redhat.com')
            bzclass = bugzilla.RHBugzilla
        else:
            bzclass = bugzilla.Bugzilla
    elif global_opt.bztype in bugzilla.classlist:
        log.info('Using Bugzilla class %s' % global_opt.bztype)
        bzclass = getattr(bugzilla, global_opt.bztype)
    else:
        parser.error("bztype must be one of: %s" % str(bugzilla.classlist))

    if bzinstance:
        bz = bzinstance
    else:
        bz = bzclass(url=global_opt.bugzilla)


    # Handle 'login' action
    if action == 'login':
        if len(args) == 2:
            (global_opt.user, global_opt.password) = args
        elif len(args) == 1:
            (global_opt.user, ) = args
        elif len(args) > 2:
            parser.error("Too many arguments for login")
        if not global_opt.user:
            sys.stdout.write('Username: ')
            user = sys.stdin.readline()
            global_opt.user = user.strip()
        if not global_opt.password:
            global_opt.password = getpass.getpass()
        sys.stdout.write('Logging in... ')
        sys.stdout.flush()
        if bz.login(global_opt.user, global_opt.password):
            print 'Authorization cookie received.'
            sys.exit(0)
        else:
            print 'failed.'
            sys.exit(1)

    # Set up authentication
    if global_opt.user:
        if not global_opt.password:
            global_opt.password = getpass.getpass()
        log.info('Using username/password for authentication')
        bz.login(global_opt.user, global_opt.password)
    elif not _is_unittest:
        if global_opt.cookiefile:
            bz.cookiefile = global_opt.cookiefile
        cookiefile = bz.cookiefile
        if os.path.exists(cookiefile):
            log.info('Using cookies in %s for authentication', cookiefile)
        else:
            # FIXME check to see if .bugzillarc is in use
            log.info('No authentication info provided.')


    ###########################
    # Run the actual commands #
    ###########################

    buglist = []
    if action == 'info':
        if args:
            parser.error("Extra arguments '%s'" % args)

        if not (opt.products or
                opt.components or
                opt.component_owners or
                opt.versions):
            parser.error("'info' command requires additional arguments")

        _do_info(bz, opt)

    elif action == 'query':
        if args:
            parser.error("Extra arguments '%s'" % args)

        buglist = do_query(bz, opt, parser)
        if opt.test_return_query:
            return buglist

    elif action == 'new':
        if args:
            parser.error("Extra arguments '%s'" % args)
        newbugs = _do_new(bz, opt)
        buglist += newbugs

    elif action == 'attach':
        if not opt.file and opt.desc:
            parser.error("attaching a file requires --file and --description")

        _do_attach(bz, opt, parser, args)

    elif action == 'modify':
        if opt.dupeid is not None:
            opt.close = "DUPLICATE"

        if not (opt.status or opt.close or
                opt.assignee or opt.qa_contact or
                opt.flag or opt.cc or opt.comment or
                opt.fixed_in):
            parser.error("'modify' command requires additional arguments")

        if not args:
            parser.error('No bug IDs given '
                         '(maybe you forgot an argument somewhere?)')

        _do_modify(bz, opt, args)

    else:
        raise RuntimeError("Unexpected action '%s'" % action)

    # If we're doing new/query/modify, output our results
    if action in ['new', 'query']:
        _format_output(bz, opt, buglist)


if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        log.debug("", exc_info=True)
        print "\ninterrupted."
        sys.exit(1)
    except socket.error, e:
        log.debug("", exc_info=True)
        print "\nConnection lost/failed: %s" % str(e)
        sys.exit(2)
    except xmlrpclib.Fault, e:
        log.debug("", exc_info=True)
        print "\nServer error: %s" % str(e)
        sys.exit(3)
    except xmlrpclib.ProtocolError, e:
        log.debug("", exc_info=True)
        print "\nInvalid server response: %d %s" % (e.errcode, e.errmsg)
        redir = e.headers.getheader("location", 0)
        if redir:
            print "Server was attempting a redirect."
            print 'Try "bugzilla --bugzilla %s ..."' % redir
        sys.exit(4)
